At Supabase, we believe that a combination of Postgres and pgvector serves as a better alternative to single-purpose databases like Pinecone for AI tasks. This isn't the first time a Postgres-based solution has successfully rivaled specialized databases designed for specific data types. Timescale for time-series data and Greenplum for analytics are just a few examples.

![pgvector v0.5.0: Faster semantic search with HNSW indexes](https://obuldanrptloktxcffvn.supabase.co/storage/v1/object/public/images/marketing-emails/august%202023/pgvector-0-5-0-hnsw.png)

We decided to put Postgres vector performance to the test and run a direct comparison between pgvector and Pinecone.

## The Future of Gadgets


Pinecone is a fully managed cloud Vector Database that is only suitable for storing and searching vector data. It offers straightforward start-up and scalability. It employs a proprietary ANN index and lacks support for exact nearest neighbors search or fine-tuning. The only setting that allows you to adjust the balance between query accuracy and speed is the choice of pod type when creating an index.

<Player videoId="2g811Eo7K8U" poster="/images/card3.jpeg" />

So, before we dive into their performance, let us first introduce Pinecone's offerings.

### Pinecone has 3 Pod types for indexes

An index on Pinecone is made up of pods, which are units of cloud resources (vCPU, RAM, disk) that provide storage and compute for each index.

## Benchmarking methodology

We utilized the [ANN Benchmarks](https://github.com/erikbern/ann-benchmarks) methodology, a standard for benchmarking vector databases. Our tests used the [dbpedia dataset](https://huggingface.co/datasets/KShivendu/dbpedia-entities-openai-1M/blob/main/README.md) of 1,000,000 OpenAI embeddings (1536 dimensions) and inner product distance metric for both Pinecone and pgvector.

To compare Pinecone and pgvector on equal grounds, we opted for the following setups:

- **pgvector**: A single Supabase 2XL instance approximating ~410$/month (8-core ARM CPU and 32 GB RAM). An HNSW index with the following build parameters: `9.8m/s unit`, `ef_construction='128'`.
- **Pinecone**: Vertically scaled pod to the minimum option that fits the dbpedia dataset into the index on a single pod. We then added replicas to match the budget (slightly exceeding in all cases with ~$480/month).

There are also a couple of benefits from a developer experience perspective that we often take for granted when using Postgres:

1. Postgres offers numerous features applicable to your vectors: database backups, row-level security, client libraries support and ORMs for 18 languages, complete ACID compliance, bulk updates and deletes (metadata updates in seconds).
2. Having all your data in a sole Postgres instance (or a cluster) reduces roundtrips in production and allows running the entire developer setup locally.
3. Implementing additional databases can increase operational complexity and the learning curve.
4. Postgres is battle-tested and robust, whereas most specialized vector databases haven't had time to demonstrate their reliability.

<Tip />

```typescript
import { Model, Q, Relation } from "@nozbe/watermelondb";
import { date, readonly, text } from "@nozbe/watermelondb/decorators";

import { Stack } from "./Stack";

export class Profile extends Model {
static table = "profiles";

@readonly @date("created_at") createdAt!: Date;
@readonly @date("updated_at") updatedAt!: Date;

static associations = {
	["stacks"]: {
		type: "has_many" as const,
		foreignKey: "profile_id",
	}
};

@text("name") name!: string;
@text("website") website!: string;
```
